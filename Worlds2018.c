#pragma config(Sensor, in1,    sideSelect,     sensorPotentiometer)
#pragma config(Sensor, in2,    zoneSelect,     sensorPotentiometer)
#pragma config(Sensor, in4,    typeSelect,     sensorPotentiometer)
#pragma config(Sensor, in7,    mobGoal,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightDrive,     sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  leftDrive,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  coneLiftSens,   sensorQuadEncoder)
#pragma config(Motor,  port2,           leftFrontMid,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           coneLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           coneLiftSec,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           coneRoll,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lift,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightFrontMid, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/


// This code is for the VEX cortex platform
#pragma platform(VEX2)



// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"



/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/


void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	SensorValue[coneLiftSens] = 0;
	bStopTasksBetweenModes = true;



	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}



/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
int leftDist = 0;
int rightDist = 0;

void trapDriveStraight(float maxPower, int encoderDist) //set to 120, not 127
{
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	float desiredPower = 0.4*maxPower;
	float rightPower = desiredPower;
	motor[leftBack] = desiredPower; //turn into own function
	motor[leftFrontMid] = desiredPower;
	motor[rightBack] = rightPower;
	motor[rightFrontMid] = rightPower;
	int lastError = 0;
	float Pterm = 0;
	float Iterm = 0;
	float Dterm = 0;
	while(abs((leftDist + rightDist) / 2) < 0.15*abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
		desiredPower = (0.4 + ((abs(leftDist + rightDist) / 2) / (0.15*abs(encoderDist)))) * maxPower;
		float rightPower = desiredPower;
		motor[leftBack] = desiredPower; //turn into own function
		motor[leftFrontMid] = desiredPower;
		motor[rightBack] = rightPower;
		motor[rightFrontMid] = rightPower;
		//can add in pid here
		//right side faster than left, so target is left side speed
		//left side remains constant, only adjust right side (master-clone pid control)
		int error = leftDist - rightDist;
		float kP = 0.0006; //PID CONSTANTS
		float kI = 0; //constants depend on weight distribution, etc. No point in tuning until robot is complete
		float kD = 0;

		if(abs(error) > 5)
		{
			Pterm = kP * error;
			Iterm = kI * error + Iterm;
			Dterm = kD * (error - lastError);
			rightPower += Pterm + Iterm + Dterm;
			if(rightPower > 126) rightPower = 127; //prevent wrapping, just in case
				if(rightPower <= -128) rightPower = -128;
			if(rightPower > desiredPower + 40) rightPower = desiredPower + 40;
			if(rightPower < desiredPower - 40) rightPower = desiredPower - 40;
			motor[rightBack] = rightPower;
			motor[rightBack] = rightPower;
			motor[rightFrontMid] = rightPower;
		}
		lastError = error;
		sleep(20); //50 Hz data collection
	}
	//WIP
	desiredPower = maxPower;
	rightPower = desiredPower;
	motor[leftBack] = desiredPower; //turn into own function
	motor[leftFrontMid] = desiredPower;
	motor[rightBack] = rightPower;
	motor[rightFrontMid] = rightPower;
	Iterm = 0;
	while(abs((leftDist + rightDist) / 2) < 0.7*abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);

		//can add in pid here
		//right side faster than left, so target is left side speed
		//left side remains constant, only adjust right side (master-clone pid control)
		int error = leftDist - rightDist;
		float kP = 0.0006; //PID CONSTANTS
		float kI = 0; //constants depend on weight distribution, etc. No point in tuning until robot is complete
		float kD = 0;
		if(abs(error) > 5)
		{
			Pterm = kP * error;
			Iterm = kI * error + Iterm;
			Dterm = kD * (error - lastError);
			rightPower += Pterm + Iterm + Dterm;
			if(rightPower > 126) rightPower = 127; //prevent wrapping, just in case
				if(rightPower <= -128) rightPower = -128;
			if(rightPower > desiredPower + 40) rightPower = desiredPower + 40;
			if(rightPower < desiredPower - 40) rightPower = desiredPower - 40;
			motor[rightBack] = rightPower;
			motor[rightBack] = rightPower;
			motor[rightFrontMid] = rightPower;
		}
		lastError = error;
		sleep(20); //50 Hz data collection
	} //WIP
	Iterm = 0;
	while(abs((leftDist + rightDist) / 2) < 0.15*abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
		desiredPower = ((1 - ((abs(leftDist + rightDist) / 2) / (0.15*abs(encoderDist)))) + 0.1) * maxPower;
		float rightPower = desiredPower;
		motor[leftBack] = desiredPower; //turn into own function
		motor[leftFrontMid] = desiredPower;
		motor[rightBack] = rightPower;
		motor[rightFrontMid] = rightPower;
		//can add in pid here
		//right side faster than left, so target is left side speed
		//left side remains constant, only adjust right side (master-clone pid control)
		int error = leftDist - rightDist;
		float kP = 0.0006; //PID CONSTANTS
		float kI = 0; //constants depend on weight distribution, etc. No point in tuning until robot is complete
		float kD = 0;

		if(abs(error) > 5)
		{
			Pterm = kP * error;
			Iterm = kI * error + Iterm;
			Dterm = kD * (error - lastError);
			rightPower += Pterm + Iterm + Dterm;
			if(rightPower > 126) rightPower = 127; //prevent wrapping, just in case
				if(rightPower <= -128) rightPower = -128;
			if(rightPower > desiredPower + 40) rightPower = desiredPower + 40;
			if(rightPower < desiredPower - 40) rightPower = desiredPower - 40;
			motor[rightBack] = rightPower;
			motor[rightBack] = rightPower;
			motor[rightFrontMid] = rightPower;
		}
		lastError = error;
		sleep(20); //50 Hz data collection
	}
	motor[leftBack] = 0; //turn into own function
	motor[leftFrontMid] = 0;
	motor[rightBack] = 0;
	motor[rightFrontMid] = 0;
}

void segDriveWithLeft(float maxLeftPower, float maxRightPower, int encoderDist) //set to 120, not 127
{
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	float desiredLeftPower = 0.4*maxLeftPower;
	float desiredRightPower = 0.4*maxRightPower;
	motor[leftBack] = desiredLeftPower; //turn into own function
	motor[leftFrontMid] = desiredLeftPower;
	motor[rightBack] = desiredRightPower;
	motor[rightFrontMid] = desiredRightPower;
	while(abs(leftDist) < 0.15*abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		//rightDist = abs(SensorValue[rightDrive]);
		desiredLeftPower = (0.4 + ((abs(leftDist)) / (0.15*abs(encoderDist)))) * maxLeftPower;
		desiredRightPower = (0.4 + ((abs(leftDist)) / (0.15*abs(encoderDist)))) * maxRightPower;
		//float rightPower = desiredPower;
		motor[leftBack] = desiredLeftPower; //turn into own function
		motor[leftFrontMid] = desiredLeftPower;
		motor[rightBack] = desiredRightPower;
		motor[rightFrontMid] = desiredRightPower;
		sleep(20); //50 Hz data collection
	}
	motor[leftBack] = maxLeftPower; //turn into own function
	motor[leftFrontMid] = maxLeftPower;
	motor[rightBack] = maxRightPower;
	motor[rightFrontMid] = maxRightPower;
	while(abs((leftDist)) < 0.7*abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);

		sleep(20); //50 Hz data collection
	} //WIP
	while(abs(leftDist) < 0.15*abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
		desiredLeftPower = ((1 - ((abs(leftDist)) / (0.15*abs(encoderDist)))) + 0.1) * maxLeftPower;
		desiredRightPower = ((1 - ((abs(leftDist)) / (0.15*abs(encoderDist)))) + 0.1) * maxRightPower;
		motor[leftBack] = maxLeftPower; //turn into own function
		motor[leftFrontMid] = maxLeftPower;
		motor[rightBack] = maxRightPower;
		motor[rightFrontMid] = maxRightPower;
		sleep(20); //50 Hz data collection
	}
	motor[leftBack] = 0; //turn into own function
	motor[leftFrontMid] = 0;
	motor[rightBack] = 0;
	motor[rightFrontMid] = 0;
}

void segDriveWithRight(float maxLeftPower, float maxRightPower, int encoderDist) //set to 120, not 127
{
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	float desiredLeftPower = 0.4*maxLeftPower;
	float desiredRightPower = 0.4*maxRightPower;
	motor[leftBack] = desiredLeftPower; //turn into own function
	motor[leftFrontMid] = desiredLeftPower;
	motor[rightBack] = desiredRightPower;
	motor[rightFrontMid] = desiredRightPower;
	while(abs(rightDist) < 0.15*abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		rightDist = abs(SensorValue[rightDrive]);
		desiredLeftPower = (0.4 + ((abs(leftDist)) / (0.15*abs(encoderDist)))) * maxLeftPower;
		desiredRightPower = (0.4 + ((abs(leftDist)) / (0.15*abs(encoderDist)))) * maxRightPower;
		motor[leftBack] = desiredLeftPower; //turn into own function
		motor[leftFrontMid] = desiredLeftPower;
		motor[rightBack] = desiredRightPower;
		motor[rightFrontMid] = desiredRightPower;
		sleep(20); //50 Hz data collection
	}
	motor[leftBack] = maxLeftPower; //turn into own function
	motor[leftFrontMid] = maxLeftPower;
	motor[rightBack] = maxRightPower;
	motor[rightFrontMid] = maxRightPower;
	while(abs((rightDist)) < 0.7*abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);

		sleep(20); //50 Hz data collection
	}
	while(abs(rightDist) < 0.15*abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
		desiredLeftPower = ((1 - ((abs(leftDist)) / (0.15*abs(encoderDist)))) + 0.1) * maxLeftPower;
		desiredRightPower = ((1 - ((abs(leftDist)) / (0.15*abs(encoderDist)))) + 0.1) * maxRightPower;
		motor[leftBack] = maxLeftPower; //turn into own function
		motor[leftFrontMid] = maxLeftPower;
		motor[rightBack] = maxRightPower;
		motor[rightFrontMid] = maxRightPower;

		sleep(20); //50 Hz data collection
	}
	motor[leftBack] = 0; //turn into own function
	motor[leftFrontMid] = 0;
	motor[rightBack] = 0;
	motor[rightFrontMid] = 0;
}

void drive(float leftPower, float rightPower, float encoderDist)
{
	motor[leftBack] = leftPower;
	motor[leftFrontMid] = leftPower;
	motor[rightBack] = rightPower;
	motor[rightFrontMid] = rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while((abs(leftDist) + abs(rightDist)) / 2 < abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
	}
	motor[leftBack] = 0;
	motor[leftFrontMid] = 0;
	motor[rightBack] = 0;
	motor[rightFrontMid] = 0;
}

void segDrive(float leftPower, float rightPower, float encoderDist)
{
	float k = 0.4;
	motor[leftBack] = k*leftPower;
	motor[leftFrontMid] = k*leftPower;
	motor[rightBack] = k*rightPower;
	motor[rightFrontMid] = k*rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while((abs(leftDist) + abs(rightDist)) / 2 < abs(0.1*encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
	}

	motor[leftBack] = leftPower;
	motor[leftFrontMid] = leftPower;
	motor[rightBack] = rightPower;
	motor[rightFrontMid] = rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while((abs(leftDist) + abs(rightDist)) / 2 < abs(0.8*encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
	}

	motor[leftBack] = k*leftPower;
	motor[leftFrontMid] = k*leftPower;
	motor[rightBack] = k*rightPower;
	motor[rightFrontMid] = k*rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while((abs(leftDist) + abs(rightDist)) / 2 < abs(0.1*encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
	}
	motor[leftBack] = 0;
	motor[leftFrontMid] = 0;
	motor[rightBack] = 0;
	motor[rightFrontMid] = 0;
}

void setDrive(float leftPower, float rightPower)
{
	motor[leftBack] = leftPower;
	motor[leftFrontMid] = leftPower;
	motor[rightFrontMid] = rightPower;
	motor[rightBack] = rightPower;
}

void driveWithRight(float leftPower, float rightPower, float encoderDist) //only reads right encoder
{	motor[leftBack] = leftPower;
	motor[leftFrontMid] = leftPower;
	motor[rightBack] = rightPower;
	motor[rightFrontMid] = rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while(abs(rightDist) < abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
	}
	motor[leftBack] = 0;
	motor[leftFrontMid] = 0;
	motor[rightBack] = 0;
	motor[rightFrontMid] = 0;
}

void driveWithLeft(float leftPower, float rightPower, float encoderDist) //only reads left encoder
{
	motor[leftBack] = leftPower;
	motor[leftFrontMid] = leftPower;
	motor[rightBack] = rightPower;
	motor[rightFrontMid] = rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while(abs(leftDist) < abs(encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
	}
	motor[leftBack] = 0;
	motor[leftFrontMid] = 0;
	motor[rightBack] = 0;
	motor[rightFrontMid] = 0;
}


void driveTime(float leftPower, float rightPower, float time)
{
	motor[leftBack] = leftPower;
	motor[leftFrontMid] = leftPower;
	motor[rightBack] = rightPower;
	motor[rightFrontMid] = rightPower;
	wait(time); //wait statements represent movement that ends in a collision (with bars) //0.4 for 10 point, _ for 20 point
	motor[leftBack] = 0;
	motor[leftFrontMid] = 0;
	motor[rightBack] = 0;
	motor[rightFrontMid] = 0;
}

void lowerMob(float time)
{
	motor[lift] = -127;
	wait(time);
	motor[lift] = 0;
}

void raiseMob(float time)
{
	motor[lift] = 127;
	wait(time);
	motor[lift] = 0;
}

void moveCone(float power, float time)
{
	motor[coneLift] = power;
	motor[coneLiftSec] = power;
	wait(time); //raise cone lift
	motor[coneLift] = 14;
	motor[coneLiftSec] = 14;
}

void setRoller(float power)
{
	motor[coneRoll] = power;
}

void escape() //response to blocking autons
{
	driveTime(127, 127, 0.7);
	lowerMob(1.3);
	driveTime(-127, -127, 0.7);
	wait(15);
}

void segDriveWithRightCondition(float leftPower, float rightPower, float encoderDist, int timeout) //only reads right encoder
{
	clearTimer(T3);
	float k = 0.4;
	motor[leftBack] = k*leftPower;
	motor[leftFrontMid] = k*leftPower;
	motor[rightBack] = k*rightPower;
	motor[rightFrontMid] = k*rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while(abs(rightDist) < abs(0.1*encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
		if(time1[T3] > timeout * 1000) escape();
	}
	motor[leftBack] = leftPower;
	motor[leftFrontMid] = leftPower;
	motor[rightBack] = rightPower;
	motor[rightFrontMid] = rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while(abs(rightDist) < abs(0.8*encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
		if(time1[T3] > timeout * 1000) escape();
	}
	motor[leftBack] = k*leftPower;
	motor[leftFrontMid] = k*leftPower;
	motor[rightBack] = k*rightPower;
	motor[rightFrontMid] = k*rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while(abs(rightDist) < abs(0.1*encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
		if(time1[T3] > timeout * 1000) escape();
	}
	motor[leftBack] = -0.4*leftPower;
	motor[leftFrontMid] = -0.4*leftPower;
	motor[rightBack] = -0.4*rightPower;
	motor[rightFrontMid] = -0.4*rightPower;
	wait(0.08);
	motor[leftBack] = 0;
	motor[leftFrontMid] = 0;
	motor[rightBack] = 0;
	motor[rightFrontMid] = 0;
}

void segDriveWithLeftCondition(float leftPower, float rightPower, float encoderDist, int timeout) //only reads left encoder
{
	clearTimer(T3);
	float k = 0.4;
	motor[leftBack] = k*leftPower;
	motor[leftFrontMid] = k*leftPower;
	motor[rightBack] = k*rightPower;
	motor[rightFrontMid] = k*rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while(abs(leftDist) < abs(0.1*encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
		if(time1[T3] > timeout * 1000) escape();
	}
	motor[leftBack] = leftPower;
	motor[leftFrontMid] = leftPower;
	motor[rightBack] = rightPower;
	motor[rightFrontMid] = rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while(abs(leftDist) < abs(0.8*encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
		if(time1[T3] > timeout * 1000) escape();
	}
	motor[leftBack] = k*leftPower;
	motor[leftFrontMid] = k*leftPower;
	motor[rightBack] = k*rightPower;
	motor[rightFrontMid] = k*rightPower;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;
	leftDist = 0;
	rightDist = 0;
	while(abs(leftDist) < abs(0.1*encoderDist)) //trap in while loop until escape conditions are met
	{
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);
		if(time1[T3] > timeout * 1000) escape();
	}
	motor[leftBack] = -0.4*leftPower;
	motor[leftFrontMid] = -0.4*leftPower;
	motor[rightBack] = -0.4*rightPower;
	motor[rightFrontMid] = -0.4*rightPower;
	wait(0.08);
	motor[leftBack] = 0;
	motor[leftFrontMid] = 0;
	motor[rightBack] = 0;
	motor[rightFrontMid] = 0;
}

task lowerMobMulti()
{
	motor[lift] = -127;
	wait(1.2);
	motor[lift] = 0;
}

task raiseMobMulti()
{
	motor[lift] = 127;
	wait(1.2);
	motor[lift] = 0;
}

task raiseConeMulti()
{
	motor[coneRoll] = 15; //hold cone in roller
	motor[coneLift] = 100;
	motor[coneLiftSec] = 100;
	wait(0.45); //raise cone lift
	motor[coneLift] = 10;
	motor[coneLiftSec] = 10;
}

task lowerConeMulti()
{
	motor[coneRoll] = 15; //hold cone in roller
	motor[coneLift] = -100;
	motor[coneLiftSec] = -100;
	wait(0.45); //raise cone lift
	motor[coneLift] = 10;
	motor[coneLiftSec] = 10;
}

task holdConeLift()
{
	while(true)
	{
		if(SensorValue[coneLiftSens] < 300)
		{
			motor[coneLift] = 80;
			motor[coneLiftSec] = 80;
		}
		else if(SensorValue[coneLiftSens] > 400)
		{
			motor[coneLift] = -90;
			motor[coneLiftSec] = -90;
		}
		else
		{
			motor[coneLift] = 16;
			motor[coneLiftSec] = 16;
		}
	}
}

task statConeLift()
{
	while(true)
	{
		if(SensorValue[coneLiftSens] < 600)
		{
			motor[coneLift] = 80;
			motor[coneLiftSec] = 80;
		}
		else if(SensorValue[coneLiftSens] > 630)
		{
			motor[coneLift] = -90;
			motor[coneLiftSec] = -90;
		}
		else
		{
			motor[coneLift] = 16;
			motor[coneLiftSec] = 16;
		}
	}
}

void secondCone()
{
	motor[coneLift] = 127;
	motor[coneLiftSec] = 127;
	wait(1);
	motor[coneLift] = 0;
	motor[coneLiftSec] = 0;
	motor[coneRoll] = 127;
	wait(0.7);
	motor[coneRoll] = 15;
	motor[coneLift] = -127;
	motor[coneLiftSec] = -127;
	wait(1.6);
	motor[coneLift] = 15;
	motor[coneLiftSec] = 15;
	motor[coneRoll] = -120;
	wait(0.3);
	motor[coneLift] = 100;
	motor[coneLiftSec] = 100;
	wait(0.2);
	motor[coneRoll] = 0;
}


void runSkills()
{
	//MULTITHREADING
	//RIGHT SIDE - attempt to multithread Jan 1
	int coneLiftHoldPower = 10;
	SensorValue[coneLiftSens] = 0;
	motor[coneRoll] = 15; //hold cone in roller
	motor[coneLift] = 90;
	motor[coneLiftSec] = 90;
	wait(0.35); //raise cone lift
	motor[coneLift] = 10;
	motor[coneLiftSec] = 10;
	startTask(lowerMobMulti);
	drive(50, 50, 20); //necessary?
	drive(127, 127, 1230); //go forward
	raiseMob(0.3); //pick up mobile goal
	startTask(raiseMobMulti);
	drive(-60, -60, 50);
	drive(-100, -100, 400);
	driveWithLeft(-5, -127, 900); //THE THIRD VALUE IS DISTANCE. MAY NEED TO BE EDITED***
	motor[coneLift] = -30;
	motor[coneLiftSec] = -30;
	wait(0.4);
	motor[coneLift] = coneLiftHoldPower;
	motor[coneLiftSec] = coneLiftHoldPower;
	motor[coneRoll] = -120; //drop cone
	wait(0.3);
	motor[coneLift] = 80;
	motor[coneLiftSec] = 80;
	wait(0.6);
	motor[coneLift] = coneLiftHoldPower;
	motor[coneLiftSec] = coneLiftHoldPower;
	motor[coneRoll] = 0;
	startTask(holdConeLift);
	//drive backwards //2800 dist
	//curve backwards
	drive(-100, -100, 100);
	driveWithLeft(90, -90, 188); //turn to 20 point //THIS IS ROTATION. THIRD VALUE IS DISTANCE.***
	driveTime(127, 127, 1.3);
	//
	driveTime(60, 60, 0.5);
	motor[leftFrontMid] = 10;
	motor[leftBack] = 10;
	motor[rightFrontMid] = 10;
	motor[rightBack] = 10;
	//drive(-40, -40, 20); //backs up to align for 20 point zone drop
	//driveTime(-10, -10, 0.04);
	lowerMob(0.8); //drop mobile goal
	//motor[lift] = 120;
	//wait(0.05);
	//motor[lift] = 0;
	wait(0.1);
	driveTime(-40, -40, 0.4);
	//motor[lift] = 60;
	driveTime(-127, -127, 0.5); //backs out after first mob goal
	//startTask(holdConeLift);
	raiseMob(0.2);
	startTask(raiseMobMulti);
	segDriveWithLeft(-100, 100, 250);
	segDrive(127, 127, 340);
	segDriveWithLeft(-100, 100, 270);
	stopTask(raiseMobMulti);
	driveTime(-100, -100, 0.2);
	driveTime(-37, -37, 0.6);
	startTask(lowerMobMulti);
	wait(0.2);

	//start on right side of bar
	/*SensorValue[coneLiftSens] = 0;
	int coneLiftHoldPower = 10;
	setRoller(15); //hold cone in roller
	moveCone(127, 0.6);
	//lowerMob(1.4);
	startTask(lowerMobMulti);
	wait(0.08);*/
	//	drive(50, 50, 50);
	segDrive(127, 127, 690); ////DRIVES FORWARD TO PICK UP FIRST MOBILE GOAL
	stopTask(lowerMobMulti);
	//startTask(raiseMobMulti);
	raiseMob(1.4); //pick up mobile goal
	//moveCone(-30, 0.5);
	//setRoller(-127); //drop cone
	//wait(0.3);
	//moveCone(80, 0.4);
	//setRoller(0);
	//startTask(holdConeLift);
	//drive(-50, -50, 50);
	drive(-127, -127, 670); ////DRIVES BACK WITH FIRST MOBILE GOAL AND CONE
	driveTime(-30, -30, 0.3); ////COLLIDE ON BAR
	drive(100, 100, 100);
	segDriveWithLeft(-100, 100, 451);
	drive(80, 80, 100);
	driveTime(30, 30, 0.4);
	setDrive(10, 10);
	lowerMob(1.3); //drop mobile goal
	wait(0.1);
	driveTime(-40, -40, 0.55); ////BACK OUT
	startTask(raiseMobMulti);
	driveTime(80, 80, 0.3);
	driveTime(30, 30, 0.3); ////COLLIDE ON BAR
	drive(-120, -120, 90);
	segDriveWithLeft(100, -100, 250); ////TURN RIGHT 90 DEGREES ***
	stopTask(raiseMobMulti);
	segDrive(120, 120, 680); ////MOVE FORWARD TO PREPARE FOR ALIGNMENT FOR SECOND MOBILE GOAL***
	segDriveWithLeft(100, -100, 260); ////TURN RIGHT 90 DEGREES TO FACE SECOND MOBILE GOAL***
	drive(-100, -100, 90);
	driveTime(-50, -50, 0.2);
	driveTime(-30, -30, 0.2); ////COLLIDE ON BAR
	startTask(lowerMobMulti);
	wait(0.08);
	segDrive(127, 127, 950); ////DRIVE TOWARD SECOND MOBILE GOAL
	stopTask(lowerMobMulti);
	raiseMob(0.2);
	startTask(raiseMobMulti);
	segDrive(-127, -127, 870); ////DRIVE BACK WITH SECOND MOBILE GOAL
	stopTask(raiseMobMulti);
	driveTime(-30, -30, 0.4); ////COLLIDE ON BAR
	segDrive(100, 100, 100);
	wait(0.05);
	segDriveWithRight(100, -100, 400); ////TURN 180 DEGREES **
	drive(80, 80, 100);
	driveTime(30, 30, 0.4);
	setDrive(10, 10);
	lowerMob(1.3); //drop mobile goal
	wait(0.1);
	driveTime(-40, -40, 0.55); ////BACK OUT
	raiseMob(1.4);
	wait(0.05);
	segDriveWithRight(-100, 100, 400); ////TURN 180 DEGREES TO FACE THIRD MOBILE GOAL **
	wait(0.05);
	drive(-80, -80, 130);
	driveTime(-60, -60, 0.2);
	driveTime(-30, -30, 0.4); ////COLLIDE ON BAR
	startTask(lowerMobMulti);
	drive(100, 100, 2400); ////DRIVE TOWARD THIRD MOBILE GOAL
	stopTask(lowerMobMulti);
	startTask(raiseMobMulti);
	drive(100, 100, 300);
	stopTask(raiseMobMulti);
	driveTime(60, 60, 0.2);
	driveTime(30, 30, 0.5); ////COLLIDE ON BAR
	segDrive(-60, -60, 100);
	segDriveWithLeft(100, -100, 250); ////TURN RIGHT 90 DEGREES **
	segDrive(60, 60, 250); ////MOVE FORWARD TOWARDS CENTER OF BARS **
	wait(0.05);
	segDriveWithLeft(-100, 100, 260); ////TURN LEFT 90 DEGREES TO FACE 20 PT ZONE **
	driveTime(127, 127, 1);
	driveTime(60, 60, 0.5);
	setDrive(10, 10);
	lowerMob(0.8); //drop mobile goal
	wait(0.1);
	driveTime(-40, -40, 0.5);
	driveTime(-127, -127, 0.4); //ideal 52 points ends here, rest is a little extra
	raiseMob(1);
	driveTime(100, 100, 0.12);
	driveTime(60, 60, 0.1);
	driveTime(30, 30, 0.4); ////COLLIDE ON BAR
	segDrive(-100, -100, 100);
	wait(0.05);
	segDriveWithRight(100, -100, 250); ////TURN RIGHT 90 DEGREES
	segDrive(60, 60, 350); ////MOVE TO ALIGN WITH FOURTH MOBILE GOAL *
	segDriveWithRight(100, -100, 260); ////TURN RIGHT 90 DEGREES TO FACE FOURTH MOBILE GOAL
	drive(-100, -100, 100);
	driveTime(-60, -60, 0.1);
	driveTime(-30, -30, 0.4); ////COLLIDE ON BAR
	startTask(lowerMobMulti);
	//lowerMob(1.2);
	drive(50,50,50);
	segDrive(100, 100, 760); ////DRIVE TO FOURTH MOBILE GOAL
	stopTask(lowerMobMulti);
	startTask(raiseMobMulti);
	wait(0.2);
	//raiseMob(1.4);
	drive(-50, -50, 50);
	segDrive(-127, -127, 660); ////DRIVE BACK WITH FOURTH MOBILE GOAL
	driveTime(-30, -30, 0.4); ////COLLIDE ON BAR
	segDrive(100, 100, 100);
	wait(0.05);
	segDriveWithRight(100, -100, 400); ////ROTATE 180 DEGREES
	drive(80, 80, 100);
	driveTime(30, 30, 0.4);
	setDrive(10, 10);
	lowerMob(1.3); //drop mobile goal
	wait(0.1);
	driveTime(-120, -80, 4); ////BACK OUT - THE END
}

void runAuton()
{
	//auton selector
	char side = 'r';
	char select = 'a';
	int zone = 10;
	bool potSelect = true; //IF THE POTS BREAK CHANGE THIS TO FALSE
	int potSide = SensorValue[sideSelect];
	int potType = SensorValue[typeSelect];
	int potZone = SensorValue[zoneSelect];
	if(potSelect)
	{
		if(potSide < 1365)
		{
			side = 'l';
		}
		if(potSide >= 1365 && potSide < 2730)
		{
			side = 'r';
		}
		if(potSide >= 2730)
		{
			side = 'd';
		}
		if(potType < 1365)
		{
			select = 'a';
		}
		if(potType >= 1365 && potSide < 2730)
		{
			select = 'b';
		}
		if(potType >= 2730)
		{
			select = 'c';
		}
		if(potZone < 1365)
		{
			zone = 20;
		}
		if(potZone >= 1365 && potZone < 2730)
		{
			zone = 10;
		}
		if(potZone >= 2730)
		{
			zone = 5;
		}
	}
	else //defaults
	{
		side = 'd';
		select = 'c';
		zone = 20;
	}
	if(side == 'l')
	{
		if(select == 'a') //multithread, 2 cone, zone selectable
		{
			//MULTITHREADING
			//zone = 20; //TODO
			int coneLiftHoldPower = 10;
			SensorValue[coneLiftSens] = 0;
			motor[coneRoll] = 15; //hold cone in roller
			startTask(holdConeLift);
			wait(0.4);
			startTask(lowerMobMulti);
			trapDriveStraight(110, 1550);
			raiseMob(0.3); //pick up mobile goal
			startTask(raiseMobMulti);
			stopTask(holdConeLift);
			wait(0.3);
			stopTask(holdConeLift);
			motor[coneLift] = -40;
			motor[coneLiftSec] = -40;
			wait(0.3);
			motor[coneLift] = coneLiftHoldPower;
			motor[coneLiftSec] = coneLiftHoldPower;
			motor[coneRoll] = -120; //drop cone
			wait(0.4);
			motor[coneLift] = 60;
			motor[coneLiftSec] = 60;
			wait(0.3);
			motor[coneLift] = coneLiftHoldPower;
			motor[coneLiftSec] = coneLiftHoldPower;
			motor[coneRoll] = 0;
			trapDriveStraight(70, 400);
			segDriveWithLeft(-70, 70, 64);
			secondCone();
			stopTask(raiseMobMulti);
			startTask(holdConeLift);
			segDriveWithLeft(80, -80, 120);
			trapDriveStraight(-100, 450);
			if(zone != 5)
			{
				driveWithRight(-127, -10, 1500); //THE THIRD VALUE IS DISTANCE. MAY NEED TO BE EDITED***
				drive(-60, -60, 60);
				segDriveWithLeft(-70, 70, 500); //turn to 20 point //THIS IS ROTATION. THIRD VALUE IS DISTANCE.***
				if(zone == 20)
				{
					driveTime(127, 127, 1.3);
					driveTime(60, 60, 0.5);
					motor[leftFrontMid] = 10;
					motor[leftBack] = 10;
					motor[rightFrontMid] = 10;
					motor[rightBack] = 10;
				}
				else if(zone == 10)
				{
					driveTime(60, 60, 0.5);
					motor[leftFrontMid] = 10;
					motor[leftBack] = 10;
					motor[rightFrontMid] = 10;
					motor[rightBack] = 10;
				}
			}
			else
			{
				driveWithRight(-127, -10, 900); //THE THIRD VALUE IS DISTANCE. MAY NEED TO BE EDITED***
				startTask(holdConeLift);
				driveWithLeft(-90, 90, 220); //turn to 20 point //THIS IS ROTATION. THIRD VALUE IS DISTANCE.***
				drive(120, 120, 100);
			}
			lowerMob(0.8); //drop mobile goal
			wait(0.1);
			driveTime(-40, -40, 0.75);
			driveTime(-127, -127, 0.8);
			motor[lift] = 0;
			motor[coneLift] = -120;
			motor[coneLiftSec] = -120;
			wait(0.8);
			motor[coneLift] = 0;
			motor[coneLiftSec] = 0;
		}
		if(select == 'b') //stationary goal to 5 pt or block
		{
			SensorValue[coneLiftSens] = 0;
			driveTime(-50, -50, 0.2);
			startTask(statConeLift);
			drive(-100, -100, 580);
			driveTime(-50, -50, 0.2);
			wait(1.2);
			setRoller(-70);
			wait(0.5);
			setRoller(0);
			stopTask(statConeLift);
			startTask(holdConeLift);
			wait(0.3);
			if(zone == 5)
			{
				driveWithLeft(120, 30, 350);
				driveWithRight(10, 120, 420);
				driveTime(80, 80, 0.7);
				trapDriveStraight(-100, 15);
				segDriveWithLeft(100, -100, 170);
				startTask(lowerMobMulti);
				wait(0.4);
				trapDriveStraight(100, 1100);
				stopTask(lowerMobMulti);
				startTask(raiseMobMulti);
				wait(0.2);
				trapDriveStraight(-100, 1300);
				driveWithLeft(110, -110, 490);
				driveTime(110, 110, 0.5);
				stopTask(raiseMobMulti);
				startTask(lowerMobMulti);
				trapDriveStraight(100, 200);
				wait(0.5);
				driveTime(-100, -100, 1);
				motor[coneLift] = -90;
				motor[coneLiftSec] = -90;
				wait(0.5);
				motor[coneLift] = 0;
				motor[coneLiftSec] = 0;
			}
			else
			{
				driveWithLeft(120, 30, 540);
				driveTime(120, 120, 2);
			}
		}
		if(select == 'c') //multithread standard auto, zone select
		{
			//MULTITHREADING
			//zone = 20; //TODO
			int coneLiftHoldPower = 10;
			SensorValue[coneLiftSens] = 0;
			motor[coneRoll] = 15; //hold cone in roller
			startTask(holdConeLift);
			wait(0.4);
			startTask(lowerMobMulti);
			trapDriveStraight(110, 1550);
			raiseMob(0.3); //pick up mobile goal
			startTask(raiseMobMulti);
			trapDriveStraight(-100, 450);
			if(zone != 5)
			{
				segDriveWithRightCondition(-127, -10, 1100, 4); //timeout of 4 seconds April 10
				drive(-60, -60, 60);
				stopTask(holdConeLift);
				motor[coneLift] = -40;
				motor[coneLiftSec] = -40;
				wait(0.3);
				motor[coneLift] = coneLiftHoldPower;
				motor[coneLiftSec] = coneLiftHoldPower;
				motor[coneRoll] = -120; //drop cone
				wait(0.3);
				motor[coneLift] = 60;
				motor[coneLiftSec] = 60;
				wait(0.3);
				motor[coneLift] = coneLiftHoldPower;
				motor[coneLiftSec] = coneLiftHoldPower;
				motor[coneRoll] = 0;
				startTask(holdConeLift);
				segDriveWithLeft(-90, 90, 210); //turn to 20 point //THIS IS ROTATION. THIRD VALUE IS DISTANCE.***
				if(zone == 20)
				{
					driveTime(127, 127, 1.3);
					driveTime(60, 60, 0.5);
					motor[leftFrontMid] = 10;
					motor[leftBack] = 10;
					motor[rightFrontMid] = 10;
					motor[rightBack] = 10;
				}
				else if(zone == 10)
				{
					driveTime(60, 60, 0.5);
					motor[leftFrontMid] = 10;
					motor[leftBack] = 10;
					motor[rightFrontMid] = 10;
					motor[rightBack] = 10;
				}
			}
			else
			{
				driveWithRight(-127, -10, 900); //THE THIRD VALUE IS DISTANCE. MAY NEED TO BE EDITED***
				stopTask(holdConeLift);
				motor[coneLift] = -40;
				motor[coneLiftSec] = -40;
				wait(0.3);
				motor[coneLift] = coneLiftHoldPower;
				motor[coneLiftSec] = coneLiftHoldPower;
				motor[coneRoll] = -120; //drop cone
				wait(0.3);
				motor[coneLift] = 60;
				motor[coneLiftSec] = 60;
				wait(0.3);
				motor[coneLift] = coneLiftHoldPower;
				motor[coneLiftSec] = coneLiftHoldPower;
				motor[coneRoll] = 0;
				startTask(holdConeLift);
				driveWithLeft(-90, 90, 220); //turn to 20 point //THIS IS ROTATION. THIRD VALUE IS DISTANCE.***
				drive(120, 120, 100);
			}
			lowerMob(0.8); //drop mobile goal
			wait(0.1);
			driveTime(-40, -40, 0.75);
			driveTime(-127, -127, 0.8);
			motor[lift] = 0;
			motor[coneLift] = -120;
			motor[coneLiftSec] = -120;
			wait(0.8);
			motor[coneLift] = 0;
			motor[coneLiftSec] = 0;
		}
	}
	else if(side == 'r')
	{
		if(select == 'a') //multithread, 2 cone, zone selectable
		{
			//MULTITHREADING
			//zone = 20; //TODO
			int coneLiftHoldPower = 10;
			SensorValue[coneLiftSens] = 0;
			motor[coneRoll] = 15; //hold cone in roller
			startTask(holdConeLift);
			wait(0.4);
			startTask(lowerMobMulti);
			trapDriveStraight(110, 1550);
			raiseMob(0.3); //pick up mobile goal
			startTask(raiseMobMulti);
			stopTask(holdConeLift);
			wait(0.3);
			stopTask(holdConeLift);
			motor[coneLift] = -40;
			motor[coneLiftSec] = -40;
			wait(0.3);
			motor[coneLift] = coneLiftHoldPower;
			motor[coneLiftSec] = coneLiftHoldPower;
			motor[coneRoll] = -120; //drop cone
			wait(0.4);
			motor[coneLift] = 60;
			motor[coneLiftSec] = 60;
			wait(0.3);
			motor[coneLift] = coneLiftHoldPower;
			motor[coneLiftSec] = coneLiftHoldPower;
			motor[coneRoll] = 0;
			trapDriveStraight(70, 400);
			segDriveWithRight(70, -70, 64);
			secondCone();
			stopTask(raiseMobMulti);
			startTask(holdConeLift);
			segDriveWithLeft(-80, 80, 120);
			trapDriveStraight(-100, 450);
			if(zone != 5)
			{
				driveWithLeft(-10, -127, 1500); //THE THIRD VALUE IS DISTANCE. MAY NEED TO BE EDITED***
				drive(-60, -60, 60);
				segDriveWithLeft(70, -70, 500); //turn to 20 point //THIS IS ROTATION. THIRD VALUE IS DISTANCE.***
				if(zone == 20)
				{
					driveTime(127, 127, 1.3);
					driveTime(60, 60, 0.5);
					motor[leftFrontMid] = 10;
					motor[leftBack] = 10;
					motor[rightFrontMid] = 10;
					motor[rightBack] = 10;
				}
				else if(zone == 10)
				{
					driveTime(60, 60, 0.5);
					motor[leftFrontMid] = 10;
					motor[leftBack] = 10;
					motor[rightFrontMid] = 10;
					motor[rightBack] = 10;
				}
			}
			else
			{
				driveWithLeft(-10, -127, 900); //THE THIRD VALUE IS DISTANCE. MAY NEED TO BE EDITED***
				startTask(holdConeLift);
				driveWithLeft(90, -90, 220); //turn to 20 point //THIS IS ROTATION. THIRD VALUE IS DISTANCE.***
				drive(120, 120, 100);
			}
			lowerMob(0.8); //drop mobile goal
			wait(0.1);
			driveTime(-40, -40, 0.75);
			driveTime(-127, -127, 0.8);
			motor[lift] = 0;
			motor[coneLift] = -120;
			motor[coneLiftSec] = -120;
			wait(0.8);
			motor[coneLift] = 0;
			motor[coneLiftSec] = 0;
		}
		if(select == 'b') //stationary goal to 5 pt or blocker
		{
			SensorValue[coneLiftSens] = 0;
			driveTime(-50, -50, 0.2);
			startTask(statConeLift);
			drive(-100, -100, 580);
			driveTime(-50, -50, 0.2);
			wait(1.2);
			setRoller(-70);
			wait(0.5);
			setRoller(0);
			stopTask(statConeLift);
			startTask(holdConeLift);
			wait(0.3);
			if(zone == 5)
			{
				driveWithRight(30, 120, 350);
				driveWithLeft(120, 10, 420);
				driveTime(80, 80, 0.7);
				trapDriveStraight(-100, 15);
				segDriveWithLeft(-100, 100, 170);
				startTask(lowerMobMulti);
				wait(0.4);
				trapDriveStraight(100, 1100);
				stopTask(lowerMobMulti);
				startTask(raiseMobMulti);
				wait(0.2);
				trapDriveStraight(-100, 1300);
				driveWithLeft(-110, 110, 490);
				driveTime(110, 110, 0.5);
				stopTask(raiseMobMulti);
				startTask(lowerMobMulti);
				trapDriveStraight(100, 200);
				wait(0.5);
				driveTime(-100, -100, 1);
				motor[coneLift] = -90;
				motor[coneLiftSec] = -90;
				wait(0.5);
				motor[coneLift] = 0;
				motor[coneLiftSec] = 0;
			}
			else
			{
				driveWithRight(30, 120, 540);
				driveTime(120, 120, 2);
			}
		}
		if(select == 'c') //multithread standard auto, zone select
		{
			//MULTITHREADING
			//zone = 20; //TODO
			int coneLiftHoldPower = 10;
			SensorValue[coneLiftSens] = 0;
			motor[coneRoll] = 15; //hold cone in roller
			startTask(holdConeLift);
			wait(0.4);
			startTask(lowerMobMulti);
			trapDriveStraight(110, 1550);
			raiseMob(0.3); //pick up mobile goal
			startTask(raiseMobMulti);
			trapDriveStraight(-100, 450);
			if(zone != 5)
			{
				segDriveWithLeftCondition(-10, -127, 1100, 4); //timeout of 4 seconds April 10
				drive(-60, -60, 60);
				stopTask(holdConeLift);
				motor[coneLift] = -40;
				motor[coneLiftSec] = -40;
				wait(0.3);
				motor[coneLift] = coneLiftHoldPower;
				motor[coneLiftSec] = coneLiftHoldPower;
				motor[coneRoll] = -120; //drop cone
				wait(0.3);
				motor[coneLift] = 60;
				motor[coneLiftSec] = 60;
				wait(0.3);
				motor[coneLift] = coneLiftHoldPower;
				motor[coneLiftSec] = coneLiftHoldPower;
				motor[coneRoll] = 0;
				startTask(holdConeLift);
				segDriveWithLeft(90, -90, 210); //turn to 20 point //THIS IS ROTATION. THIRD VALUE IS DISTANCE.***
				if(zone == 20)
				{
					driveTime(127, 127, 1.3);
					driveTime(60, 60, 0.5);
					motor[leftFrontMid] = 10;
					motor[leftBack] = 10;
					motor[rightFrontMid] = 10;
					motor[rightBack] = 10;
				}
				else if(zone == 10)
				{
					driveTime(60, 60, 0.5);
					motor[leftFrontMid] = 10;
					motor[leftBack] = 10;
					motor[rightFrontMid] = 10;
					motor[rightBack] = 10;
				}
			}
			else
			{
				driveWithLeft(-10, -127, 900); //THE THIRD VALUE IS DISTANCE. MAY NEED TO BE EDITED***
				stopTask(holdConeLift);
				motor[coneLift] = -40;
				motor[coneLiftSec] = -40;
				wait(0.3);
				motor[coneLift] = coneLiftHoldPower;
				motor[coneLiftSec] = coneLiftHoldPower;
				motor[coneRoll] = -120; //drop cone
				wait(0.3);
				motor[coneLift] = 60;
				motor[coneLiftSec] = 60;
				wait(0.3);
				motor[coneLift] = coneLiftHoldPower;
				motor[coneLiftSec] = coneLiftHoldPower;
				motor[coneRoll] = 0;
				startTask(holdConeLift);
				driveWithLeft(90, -90, 220); //turn to 20 point //THIS IS ROTATION. THIRD VALUE IS DISTANCE.***
				drive(120, 120, 100);
			}
			lowerMob(0.8); //drop mobile goal
			wait(0.1);
			driveTime(-40, -40, 0.75);
			driveTime(-127, -127, 0.8);
			motor[lift] = 0;
			motor[coneLift] = -120;
			motor[coneLiftSec] = -120;
			wait(0.8);
			motor[coneLift] = 0;
			motor[coneLiftSec] = 0;
		}
	}
	else // defense auton selected
	{
		if(select == 'a') //curve to left then forward
		{
			driveTime(50, 127, 1);
			driveTime(127, 127, 4.5);
		}
		else if(select == 'b') //curve to right then forward
		{
			driveTime(127, 50, 1);
			driveTime(127, 127, 4.5);
		}
		else if(select == 'c') //straight forward
		{
			driveTime(127, 127, 5.5);
		}
	}
}

task autonomous()
{
	runAuton();
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
bool reversed = true;
bool antidrop = false;
bool testing = true; //true to enable 8R, false to disable
int desiredPos = 0;
int currentPos = 0;

void adjustMobGoalLift(int targValue)
{
	float kP = 0.03;
	int currentValue = SensorValue[mobGoal];
	motor[lift] = kP * (targValue - currentValue);
}

task HPConeLift()
{
	int curVal = SensorValue[coneLiftSens];
	stopTask(holdConeLift);
	bool outOfRange = true;
	if(curVal < 710 || curVal > 740) outOfRange = true;
	else outOfRange = false;
	while(outOfRange)
	{
		if(curVal < 710)
		{
			motor[coneLift] = 80;
			motor[coneLiftSec] = 80;
		}
		else if(curVal > 740)
		{
			motor[coneLift] = -90;
			motor[coneLiftSec] = -90;
		}
		curVal = SensorValue[coneLiftSens];
		if(curVal < 710 || curVal > 740) outOfRange = true;
		else outOfRange = false;
	}
	if(!outOfRange)
	{
		startTask(holdConeLift);
		stopTask(HPConeLift);
	}
}

task usercontrol()
{
	// User control code here, inside the loop
	SensorValue[coneLiftSens] = 0;
	SensorValue[leftDrive] = 0;
	SensorValue[rightDrive] = 0;

	while(true)
	{
		//update vars
		leftDist = abs(SensorValue[leftDrive]);
		rightDist = abs(SensorValue[rightDrive]);

		//deadzone check, update vars
		int deadzone = 20;
		int Channel3 = vexRT[Ch3];
		int Channel1 = vexRT[Ch1];
		if(abs(vexRT[Ch3]) < deadzone) Channel3 = 0;
		if(abs(vexRT[Ch1]) < deadzone) Channel1 = 0;

		// drive code
		if(!reversed)
		{
			motor[leftBack] = Channel3 + Channel1;
			motor[leftFrontMid] = Channel3 + Channel1;
			motor[rightBack] = Channel3 - Channel1;
			motor[rightFrontMid] = Channel3 - Channel1;
		}
		else
		{
			motor[leftBack] = -Channel3 + Channel1;
			motor[leftFrontMid] = -Channel3 + Channel1;
			motor[rightBack] = -Channel3 - Channel1;
			motor[rightFrontMid] = -Channel3 - Channel1;
		}

		if(vexRT[Btn8D] == 1 && time1[T1] > 700) //reverses driving direction for more intuitive cone handling
		{
			clearTimer(T1);
			reversed = !reversed;
		}

		if(vexRT[Btn5U] == 1) //cone lift, partner controller
		{
			motor[coneLift] = -127;
			motor[coneLiftSec] = -127;
			desiredPos = currentPos = SensorValue[coneLiftSens];
		}
		else if(vexRT[Btn5D] == 1)
		{
			motor[coneLift] = 127;
			motor[coneLiftSec] = 127;
			desiredPos = currentPos = SensorValue[coneLiftSens];
		}
		else if(abs(vexRT[Ch3Xmtr2]) >= 20)
		{
			motor[coneLift] = vexRT[Ch3Xmtr2];
			motor[coneLiftSec] = vexRT[Ch3Xmtr2];
		}
		else if(SensorValue[coneLiftSens] < 300) //MUST INITIALIZE SENSOR, STARTS AT 0, LIFT MUST START IN CONSISTENT POSITION
		{
			motor[coneLift] = 16;
			motor[coneLiftSec] = 16;
		}
		else if(SensorValue[coneLiftSens] > 600)
		{
			motor[coneLift] = -16;
			motor[coneLiftSec] = -16;
		}
		else
		{
			motor[coneLift] = 0;
			motor[coneLiftSec] = 0;
		}

		if(vexRT[Btn7U] == 1 || vexRT[Btn6UXmtr2] == 1) //cone roller
		{
			motor[coneRoll] = 127;
			antidrop = true;
		}
		else if(vexRT[Btn7D] == 1 || vexRT[Btn6DXmtr2] == 1)
		{
			motor[coneRoll] = -127;
			antidrop = false;
		}
		else if(antidrop)
		{
			motor[coneRoll] = 15;
		}
		else
		{
			motor[coneRoll] = 0;
		}



		if(vexRT[Btn6U] == 1) //mobile goal lift
		{
			motor[lift] = 127;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[lift] = -127;
		}
		else if(abs(vexRT[Ch2Xmtr2]) >= 20)
		{
			motor[lift] = vexRT[Ch2Xmtr2];
		}
		else
		{
			motor[lift] = 0;
		}

		if(vexRT[Btn8R] == 1 && testing)
		{
			runAuton();
			//trapDriveStraight(100, 2500);
			//drive(100, 100, 2500);
		}
		if(vexRT[Btn7LXmtr2] == 1)
		{
			SensorValue[coneLiftSens] = 0;
		}
		if(vexRT[Btn5UXmtr2] == 1)
		{
			//adjustMobGoalLift(1500); //TODO
		}
		if(vexRT[Btn5DXmtr2] == 1)
		{
			//startTask(HPConeLift); //TODO
		}
	}
}
